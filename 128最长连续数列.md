## 128. 最长连续序列

**题目描述**

给定一个未排序的整数数组 `nums`，找出数字 **连续** 的最长序列（不要求序列元素在原数组中的下标连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

---

### 示例 1

**输入：**

```text
nums = [100, 4, 200, 1, 3, 2]
```

**输出：**

```text
4
```

**解释：**
最长连续序列是 `[1, 2, 3, 4]`，其长度为 `4`。

---

### 示例 2

**输入：**

```text
nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
```

**输出：**

```text
9
```

---

### 示例 3

**输入：**

```text
nums = [1, 0, 1, 2]
```

**输出：**

```text
3
```

---

### 提示

* `0 <= nums.length <= 10^5`
* `-10^9 <= nums[i] <= 10^9`

大致可以分成 **3 大类思路**，其中第 2 种是最推荐、也是面试标准答案。

---

### 方法一：排序 + 一次扫描（O(n log n)）

**思路：**

1. 若数组为空，直接返回 0。
2. 对 `nums` 排序。
3. 从左往右扫一遍：

   * 跳过重复元素（`nums[i] == nums[i-1]`）。
   * 如果 `nums[i] == nums[i-1] + 1`，说明连续，当前长度 `curLen++`。
   * 否则，说明断开了，更新答案 `ans = max(ans, curLen)`，并把 `curLen` 重新置 1。
4. 扫描结束后，再用最后一次 `curLen` 更新一次答案。

**复杂度：**

* 排序 O(n log n)，扫描 O(n)，总的 **O(n log n)**，空间 O(1) 或 O(n)（看排序是否原地）。

**优点 / 缺点：**

* 好写、直观；
* 但不满足题目要求的 O(n) 时间复杂度，只能算“次优/备用解法”。

---

### 方法二：哈希集合 + 只从“起点”往右扩展（O(n)，标准解）

这个就是我刚才给你讲的那种。

**核心思想：**

1. 用 `unordered_set<int>` 把所有数存起来，支持 O(1) 查找。
2. 遍历每个 `num`，只在它是“某段连续序列的最左边”（即 `num-1` 不在集合里）时，从 `num` 往右找 `num+1, num+2, ...`，统计长度。
3. 用一个变量维护最长长度。

**复杂度：**

* 建集合 O(n)；
* 每个数最多被 while 扩展访问一次；
* 总体 **O(n)** 时间，O(n) 空间。

**优点 / 缺点：**

* 满足题目 O(n) 要求，写法也不复杂；
* 是 LeetCode 官方 & 面试官最希望你写出的解法。

---

### 方法三：哈希表“区间合并”/并查集思想（O(n)，稍微更高级）

这一类有两种常见写法，本质都在“把连续的数字段合并成区间 / 集合”。

#### 3.1 哈希表记录“区间边界长度”（Interval Hash）

**关键想法：**

* 用一个 `unordered_map<int,int> mp`，只在 **连续段的左右边界** 上记录“该段长度”。
* 对每个新来的 `x`：

  1. 如果 `x` 已经在 `mp` 中，直接跳过（防止重复处理）。
  2. 看 `x-1` 和 `x+1` 有没有出现过：

     * `left = mp[x-1]` 表示以 `x-1` 结尾的连续段长度；
     * `right = mp[x+1]` 表示以 `x+1` 开头的连续段长度；
     * 当前新段的总长度 `len = left + 1 + right`。
  3. 更新新段的左右边界：

     * `mp[x - left] = len`（新段最左端）
     * `mp[x + right] = len`（新段最右端）
       中间的元素不用存。
  4. 用 `len` 更新答案。

**直观理解：**

* 每次插入一个数字，就把它和左边的连续段、右边的连续段“连成一条更长的段”，并在新段的两端记录长度。
* 这样合并的总次数是 O(n)，每次操作都是 O(1) 均摊。

**优点：**

* 也能做到 O(n)；
* 对“流式插入一堆数，然后随时想知道最长连续段”的场景很适合。

---

#### 3.2 并查集（Union-Find）

**思路：**

1. 用一个哈希表把每个数映射到一个下标 `id`：`value -> index`。
2. 再用并查集（Union-Find）结构维护“相邻数字属于同一个集合”：

   * 遍历所有数 `x`，如果 `x+1` 在数组中，就把 `id(x)` 和 `id(x+1)` 合并。
3. 并查集里维护每个集合的大小，最后找最大大小就是最长连续序列长度。

**复杂度：**

* 并查集每次合并近似 O(1)（严格说是 α(n)，极慢的增函数）；
* 总体也是 O(n)。

**特点：**

* 思想上比较通用，适合需要维护“动态连通区间”的变形题；
* 代码量会比方法二略多，面试时一般不会优先写这个，但在算法竞赛或复杂题里很常见。

---

### 小结

如果是你刷题 / 面试，推荐记住这三种层次：

1. **排序 + 扫描**：好理解，但 O(n log n)。
2. **哈希 set + 从起点扩展**：代码最简洁，**标准 O(n) 解**。
3. **区间合并 / 并查集**：思想更通用，也可 O(n)，适合进阶理解。

你要是愿意，下一步我可以：

* 帮你分别写出 **两种 C++ 实现**（排序版 + 哈希版），
* 或者只写哈希版，然后带你一行行讲清楚每句代码在干什么。

