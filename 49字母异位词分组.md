## 49. 字母异位词分组

给你一个字符串数组 `strs`。
**要求：** 把其中是「字母异位词」的字符串放到同一个小组里，并返回所有分组组成的列表。
分组和分组内字符串的顺序都 **不作要求**。

> 字母异位词：两个字符串中，**每种字母出现的次数都相同**，只是排列顺序不同。
> 例如 `"eat"`、`"tea"`、`"ate"` 互为字母异位词。

---

### 示例 1

* 输入：`strs = ["eat","tea","tan","ate","nat","bat"]`
* 一种可能的输出：`[["bat"],["nat","tan"],["ate","eat","tea"]]`

说明：

* `"nat"` 和 `"tan"` 是一组字母异位词。
* `"ate"`、`"eat"` 和 `"tea"` 是一组字母异位词。
* `"bat"` 在这个数组中找不到别的异位词，只能单独成组。

---

### 示例 2

* 输入：`strs = [""]`
* 输出：`[[""]]`

---

### 示例 3

* 输入：`strs = ["a"]`
* 输出：`[["a"]]`

---

### 约束

* `1 <= strs.length <= 10^4`
* `0 <= strs[i].length <= 100`
* `strs[i]` 仅包含小写英文字母



* 思路一：**排序作为 key**
* 思路二：**字母频次数组作为 key**（就是你之前看到 `cnt[26]` 那个）

---

## 思路一：排序后当作“标准形态”做 key

**核心想法：**

如果两个字符串是字母异位词，那么

> 把它们的字母排好序之后，一定得到 **完全一样** 的字符串。

比如：

* `"eat"`、`"tea"`、`"ate"`
  排序后都是 `"aet"`
* `"tan"`、`"nat"`
  排序后都是 `"ant"`

所以我们可以：

1. 准备一个哈希表 `unordered_map<string, vector<string>> mp;`

   * key：排序后的字符串（标准形态）
   * value：所有能排成这个形态的原始字符串列表

2. 遍历 `strs` 里的每个单词 `s`：

   * 拷贝一份：`t = s`
   * 对 `t` 排序：`sort(t.begin(), t.end());`
   * 把原始的 `s` 插入到 `mp[t]` 这个桶中

3. 遍历哈希表，把所有 `value` 收集起来就是答案。

**时间复杂度：**

* 假设有 `n` 个字符串，每个最长长度为 `k`
* 对每个字符串排序：`O(k log k)`
* 总时间：`O(n * k log k)`
* 空间：存 map + 存结果，大约 `O(n * k)`

**优点：**

* 特别直观、好理解
* 代码简单（关键就一行 `sort`）

**缺点：**

* 每个字符串都要排序一遍，对长字符串时会慢一些（有 `log k` 因子）

---

## 思路二：26 个字母频次数组作为 key（`cnt[26]`）

这个就是你之前看到那段 `cnt[26]` + `key += to_string(cnt[i]);` 的做法。

**核心想法：**

字母异位词的本质是：

> **对应的 26 个字母，出现次数一模一样。**

比如 `"eat"` 和 `"tea"`：

* `'a'`：1 次
* `'e'`：1 次
* `'t'`：1 次
* 其它 23 个字母：0 次

只要统计出每个字符串的 **26 维频次向量**，
两个字符串如果这 26 个数字完全一致 → 它们必然是字母异位词。

### 具体做法：

1. 同样准备一个哈希表：`unordered_map<string, vector<string>> mp;`
   不过这里 key 不是排序后的字符串，而是根据频次构造出来的一个“编码串”。

2. 对每个字符串 `s`：

   ```cpp
   int cnt[26] = {0};
   for (char c : s) {
       cnt[c - 'a']++;
   }
   ```

   * `cnt[0]` 表示 `'a'` 的次数
   * `cnt[1]` 表示 `'b'` 的次数
   * …
   * `cnt[25]` 表示 `'z'` 的次数

3. 把这 26 个数字拼成一个 **唯一的 key**。
   （需要用分隔符防止歧义，所以会看到那种写法）：

   ```cpp
   string key;
   key.reserve(26 * 3);      // 预留一点空间防止反复扩容
   for (int i = 0; i < 26; ++i) {
       key.push_back('#');                // 分隔符
       key += to_string(cnt[i]);          // 把数字拼到字符串后面
   }
   ```

   例如 `"eat"` 的 `cnt` 可能是：

   ```text
   [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]
   ```

   对应的 key 大致像：

   ```text
   "#1#0#0#0#1#0#0#0#0#0#0#0#0#0#0#0#0#0#0#0#1#0#0#0#0#0"
   ```

4. 用这个 key 把原串丢进 map：

   ```cpp
   mp[key].push_back(s);
   ```

5. 最后和之前一样，把哈希表里的所有 `value` 收集出来就行。

**时间复杂度：**

* 每个字符串，只需要 **一次线性扫描**，统计次数：`O(k)`
* 不需要排序，所以没有 `log k`
* 总时间：`O(n * k)`
* 空间：`O(n * k)`（存结果），key 是固定 26 维，比直接排序稍微更“规整”。

**优点：**

* 理论上比排序法更快（少了 `log k`），尤其是字符串很长时更有优势；
* 不依赖排序，比较适合「固定小字母表」的场景（比如只含 `a-z`）。

**缺点：**

* 代码比排序法多几行，不如第一种一眼看懂；
* 需要自己构造 key，刚开始看会有点懵（你之前就问了 `cnt` 和 `key` 是啥）。

---

## 两种思路的对比总结

* **本质都是：把“同一组异位词”映射到“同一个 key”，用哈希表分组。**
* 差别只在于这个 key 怎么设计：

| 方法       | key 的含义       | 每个字符串耗时    | 适用场景             |
| -------- | ------------- | ---------- | ---------------- |
| 排序作为 key | 排序后的字符串       | O(k log k) | 写法简单，通用，便于一眼看懂   |
| 计数作为 key | 26 维字母出现次数的编码 | O(k)       | 字母表固定（a-z），更高效一些 |

在刷题时，一般：

* **先写排序版**（好理解、方便过）；
* 再尝试写一遍频次数组版，加深对哈希映射 + key 设计的理解。

如果你愿意，我可以直接给你两份完整的 C++ 代码，带上时间复杂度和空间复杂度的注释，你可以丢进 GitHub 当模板。
