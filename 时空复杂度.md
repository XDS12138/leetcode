
# 一、时间复杂度（Time Complexity）

## 1. 时间复杂度是什么？

时间复杂度描述的是：**当输入规模 (n) 增大时，算法运行时间如何增长**。

* 不是精确的“几毫秒”，而是**增长趋势**；
* 忽略常数项、低次项，只保留主导项；
* 常用大 O 记号：(O(f(n)))。

常见复杂度从“快”到“慢”：

[
O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(2^n) < O(n!)
]

---

## 2. 渐进符号：O / Θ / Ω

* **大 O（Big-O）**：上界，最常用

  * (T(n) = O(f(n)))：当 (n) 足够大时，运行时间不会比 (f(n)) 差太多（最多差一个常数倍）。

* **Θ（Theta）**：紧确界

  * (T(n) = \Theta(f(n)))：(T(n)) 同阶增长，不快不少；
  * 通俗：**上界下界都差不多就是它**。

* **Ω（Omega）**：下界

  * (T(n) = \Omega(f(n)))：当 (n) 足够大时，运行时间至少像 (f(n)) 这么大。

一般写算法复杂度时，用 **大 O** 就够了；
如果你能证明“既是 O 又是 Ω”，就可以写 **Θ**，更严谨。

---

## 3. 最好情况 / 最坏情况 / 平均情况

* **最坏情况（Worst Case）**：输入特别糟糕，算法跑得最慢

  * 最常见的复杂度描述方式。
* **最好情况（Best Case）**：输入特别理想，算法跑得最快

  * 比如查找数组第一个元素。
* **平均情况（Average Case）**：随机输入情况下的期望复杂度

  * 更真实，但分析起来通常更难。

例：线性查找

```cpp
int find(const vector<int>& a, int x) {
    for (int i = 0; i < (int)a.size(); ++i) {
        if (a[i] == x) return i;
    }
    return -1;
}
```

* 最好：(O(1))（第一个就是）
* 最坏：(O(n))（在最后或不存在）
* 平均：(O(n))（按期望算大概也是一半长度，但忽略常数，还是 (O(n))）

---

## 4. 计算时间复杂度的常用套路

### 4.1 基本规则

1. **顺序结构**：总时间 = 各部分之和 → 取最大阶

   ```cpp
   // O(n) + O(n^2) -> O(n^2)
   ```

2. **分支结构**：取复杂度最大的分支

   ```cpp
   if (...) { O(n) } else { O(n^2) } -> O(n^2)
   ```

3. **循环结构**：单次循环复杂度 × 循环次数

   * 例如：循环执行 n 次，每次 O(1) → 总 O(n)。

4. **嵌套循环**：各层循环次数相乘

   * 双重 for：(n \times n = n^2) → (O(n^2))。

5. **递归**：写出递推式，用主定理等解

   * 如：(T(n) = 2T(n/2) + O(n) \Rightarrow T(n) = O(n\log n))

---

### 4.2 循环例子

#### 例 1：单层循环

```cpp
for (int i = 0; i < n; ++i) {
    // O(1)
}
```

* 执行 n 次 → (O(n))

#### 例 2：双层循环

```cpp
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) {
        // O(1)
    }
}
```

* 内层：n 次
* 外层：n 次
  → 总次数约 (n^2) → **(O(n^2))**

#### 例 3：线性嵌套随索引变化

```cpp
for (int i = 0; i < n; ++i) {
    for (int j = 0; j <= i; ++j) {
        // O(1)
    }
}
```

次数为：
[
1 + 2 + \cdots + n = \frac{n(n+1)}{2} = O(n^2)
]

---

### 4.3 对数级复杂度

当每次操作把问题规模“缩小一半/固定比例”时，常出现 (\log n)。

#### 例：二分查找

```cpp
int binary_search(const vector<int>& a, int x) {
    int l = 0, r = (int)a.size() - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (a[mid] == x) return mid;
        else if (a[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}
```

* 每一步把搜索空间减半；
* 减到只剩 1 个元素大概需要 (\log_2 n) 步；
* 每步 O(1) → **总复杂度 (O(\log n))**。

---

### 4.4 递归与主定理（简版）

对形如

[
T(n) = aT\left(\frac{n}{b}\right) + f(n)
]

的递归，常用**主定理**判断复杂度：

* (a)：子问题个数
* (n/b)：子问题规模
* (f(n))：合并子问题的额外开销

**经典例子 1：归并排序**

```cpp
void merge_sort(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) / 2;
    merge_sort(l, mid);      // T(n/2)
    merge_sort(mid+1, r);    // T(n/2)
    merge(l, mid, r);        // O(n)
}
```

递推式：

[
T(n) = 2T(n/2) + O(n)
]

结论：**(T(n) = O(n\log n))**。

**经典例子 2：快速排序（平均情况）**

平均递推式和归并类似，也得到：

[
T(n) = O(n\log n)
]

但最坏情况下（每次划分极不平衡）会退化到 (O(n^2))。

---

## 5. 多变量时间复杂度

有时算法依赖多个参数，例如：

* 图：节点数 (V)，边数 (E)；
* 矩阵：行数 (n)，列数 (m)。

这时应写成：

* BFS：(O(V + E))
* 矩阵相乘（朴素）：(O(n^3))
* 矩阵遍历：(O(nm))

不要强行把多参数都压成“n”，会丢信息。

---

## 6. 均摊（Amortized）时间复杂度

有些操作**大部分时候很快，偶尔一次很慢**，但平均下来仍然很划算。典型例子：

### 例：动态数组 `vector::push_back`

* 平常 push：O(1)
* 扩容时：要申请新内存并拷贝旧数据 → O(n)

然而，随着容量指数增长，可以证明 m 次 push 的总时间是 O(m)，于是：

> **均摊复杂度（amortized）为 (O(1)) 每次**

常见均摊 O(1) 操作：

* `vector::push_back`（尾部插入）
* `stack` / `queue` 入栈出栈
* 带扩容的哈希表插入（平均情况）

---

## 7. 算法设计中的时间复杂度取舍

* **低复杂度 > 高复杂度**（在 n 大时更重要）
* 为了换更低时间，有时会多用一点空间（典型：哈希表、预处理）
* 真实工程中，还要考虑：

  * 常数因子（同为 O(n)，有的慢很多）
  * 缓存友好性（连续内存 vs 链表）
  * 可并行性（是否易于多线程/多核）

---

# 二、空间复杂度（Space Complexity）

## 1. 空间复杂度是什么？

空间复杂度描述：**当输入规模为 (n) 时，算法额外需要多少存储空间**。

* 这里关注的是**额外空间**（extra space），不包括“输入本身”；
* 同样使用大 O 记号：(S(n))。

通常会区分：

* **原地（in-place）**：仅使用 O(1) 额外空间；
* **非原地**：使用 O(n)、O(n^2)… 额外空间。

---

## 2. 空间复杂度包含哪些东西？

理论上包括：

1. **代码空间**：保存程序本身的指令

   * 对于复杂度分析来说，当常数忽略：O(1)。

2. **静态存储空间**：全局变量、静态变量等

   * 与输入规模无关：O(1)。

3. **栈空间（stack）**：

   * 函数参数、局部变量、返回地址；
   * 递归调用会叠加栈帧：深度为 d，则栈空间 ~ O(d)。

4. **堆空间（heap）**：

   * 动态申请的内存，如 `new` / `malloc`，`vector` / `map` / `unordered_map` 的内部存储等。

在算法分析时，通常：

* 把和 n 线性/平方关系的空间归入复杂度；
* 忽略常数大小的代码/全局变量。

---

## 3. 常见空间复杂度例子

### 3.1 O(1)：常数空间

只使用固定数量变量，与输入规模无关。

```cpp
int sum(const vector<int>& a) {
    int s = 0;           // O(1)
    for (int x : a) {    // 不额外开辟数组
        s += x;
    }
    return s;
}
```

这里空间复杂度：**(O(1))**
（不把输入 `a` 的空间算进去）

---

### 3.2 O(n)：线性空间

额外需要和输入规模成正比的空间。

```cpp
vector<int> copy_array(const vector<int>& a) {
    vector<int> b(a.size());  // O(n)
    for (int i = 0; i < (int)a.size(); ++i) {
        b[i] = a[i];
    }
    return b;
}
```

* 存储 b 需要 n 个元素空间 → **(O(n))**。

再如：深度优先搜索（DFS）用于存储访问标记和递归栈：

```cpp
vector<vector<int>> g;  // 邻接表
vector<bool> vis(n);    // O(n)

void dfs(int u) {
    vis[u] = true;
    for (int v : g[u]) if (!vis[v]) dfs(v);
}
```

* `vis` 占 (O(n))；
* 递归栈最深到 n（链式图）→ 再加 (O(n))；
* 总空间复杂度：**(O(n))**。

---

### 3.3 O(n^2)：二维结构

矩阵 / 图的邻接矩阵 等常见。

```cpp
vector<vector<int>> mat(n, vector<int>(n, 0));
```

* 需要存储 (n \times n) 个元素 → **(O(n^2))**。

---

## 4. 递归与空间复杂度

递归函数会使用**栈空间**。
如果递归最大深度为 d，且每层使用 O(1) 额外空间，则递归栈占用 O(d)。

### 例：递归求和

```cpp
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);
}
```

* 递归深度：n
* 每层栈帧开销：O(1)
* 总额外空间：**(O(n))**

### 例：归并排序的空间复杂度

```cpp
void merge_sort(...) {
    // 递归划分 + 合并时使用临时数组
}
```

* 辅助数组：O(n)
* 递归深度：O(log n)，栈空间 O(log n)
* 整体空间复杂度：**O(n)**（主导项是辅助数组）

---

## 5. 就地算法（In-place）与非就地算法

* **就地（in-place）**：额外空间是 O(1)

  * 原地快排（递归栈除外）、原地堆排序、一些双指针算法等。
* **非就地**：需要额外 O(n) 或更多空间

  * 归并排序（需要辅助数组）、很多动态规划（需要 DP 表）。

### 例：原地交换

```cpp
void reverse(vector<int>& a) {
    int i = 0, j = (int)a.size() - 1;
    while (i < j) {
        swap(a[i], a[j]);  // O(1)
        ++i; --j;
    }
}
// 空间复杂度 O(1)
```

---

## 6. 动态规划中的空间优化

很多 DP 问题，初始写法会开一个二维数组：O(n^2)；
但如果状态转移只依赖于“上一行/上一列”，可降为 O(n)。

### 例：1D DP 优化

原始（二维）：

```cpp
int dp[n+1][m+1]; // O(nm)
```

优化后（滚动数组）：

```cpp
int dp[2][m+1];   // O(m)
```

甚至进一步优化为：

```cpp
int dp[m+1];      // O(m)
```

**空间复杂度分析要点：**

* 看状态有多少维；
* 看能否只保留“上一轮”的结果；
* 判断是否需要完整路径（如果要恢复路径，往往不能完全优化空间）。

---

## 7. 时间 vs 空间 的权衡

很多时候，你需要在“时间”和“空间”之间做取舍（Time–Space Tradeoff）：

* 开一个哈希表，查找时间从 O(n) 降到 O(1)，**用空间换时间**；
* 使用位图（bitset）代替 bool 数组，**用更复杂的操作换更少空间**；
* 预处理所有可能结果存表（DP / 记忆化），避免重复计算。

简单记忆：

* **时间不够 → 多浪费点空间（缓存、表、索引结构）**
* **空间不够 → 牺牲一些时间（多次计算、压缩存储）**

---

## 8. 快速判断空间复杂度的小技巧

1. 看你**额外开了多少与 n 有关的数组/容器**：

   * 1 个长度为 n 的数组：O(n)
   * 1 个 n×n 的矩阵：O(n^2)
   * 若只用若干标量变量：O(1)

2. 注意**递归深度**：

   * 最大深度 d → 栈空间 O(d)

3. 注意容器内部：

   * `vector<int> v(n);`：O(n)
   * `vector<vector<int>> g(n);` + 总边数 m：O(n + m)
   * `unordered_map<Key,Value>` 大致 O(元素个数)

---



